# Linear Approximation of Implicit Functions from Rn to Rk

This program was made by Professor [Antonio Castelo Filho](http://conteudo.icmc.usp.br/Portal/Pessoas/Detalhes.php?id=132404) and is uploaded here with his permission.

The program's goal it to generate Linear Approximations by Parts for Implicit Functions from Rn to Rk. Given a function, or a system of functions, it will generate an approximation of said functions where it equals 0, dividing the space in order to do so. All of the approximations will be convex.

Those approximations can be then be visualized using [TrueNgine](http://github.com/GSBicalho/TrueNgine), an N-Dimensional Renderer which can read the output file.

## Methods of Generation

There are two functions that can be used to generate the approximation.

### MarchingSimplex

The **MarchingSimplex** function receives 7 parameters.

`MarchingSimplex(n, k, First, Last, Division, Func, filename);`

`n` - The number of dimensions of the function's domain.

`k` - The number of dimensions of the function's codomain.

`First` - An array of size `n` containing the coordinates of the point where we will start dividing the space.

`Last` - An array of size `n` containing the coordinates of the point where we will stop dividing the space.

`Division` - An array containing how many times we will divide the space in each dimension.

`Func` - The function we want to approximate.

`filename` - The file to which we will output the resulting approximation.

This function first divides the space into `n`-dimensional simplexes, from `First` to `Last`, using the `Division` array to chech how many times it will divide in each dimension. Then, it will chech to see if the `Func` crosses each of the simplexes, and approximate it if it does.

Once it is finished, it will output the results to `filename`

### ContinuationSimplex

The **ContinuationSimplex** function receives 8 parameters.

`ContinuationSimplex(n, k, First, Last, Division, FirstPoint, Func, filename);`

`n` - The number of dimensions of the function's domain.

`k` - The number of dimensions of the function's codomain.

`First` - An array of size `n` containing the coordinates of the point where we will start dividing the space.

`Last` - An array of size `n` containing the coordinates of the point where we will stop dividing the space.

`Division` - An array containing how many times we will divide the space in each dimension.

`FirstPoint` - An array containing the coordinates of the first point to be checked.

`Func` - The function we want to approximate. It must receive two parameters: the dimension of its domain and the actual input values.

`filename` - The file to which we will output the resulting approximation.

This function works similarly to the **MarchingSimplex**, except that it requires a `FirstPoint` where `Func` is 0 to start. It then only checks the simplexes to where it knows the function continues to, instead of sweeping the entire space.

Note that, given that it follows the function to places where it is continuous, if the function generates two separate areas it will only reach one of them and therefore not approximate the other. It may be faster than the **MarchingSimplex**, but it also may not, given the nature of the chosen function.

## Examples

```
First      = [-1.1 -1.1 -1.1 -1.1];
Last       = [ 1.1  1.1  1.1  1.1];
Division   = [ 5    5    5    5  ]; 

MarchingSimplex(4, 1, First, Last, Division, @sphere4, 'sphere4.pol');

function [f] = sphere5(n,v) 
	f(1) = v(1)*v(1) + v(2)*v(2) + v(3)*v(3) + v(4)*v(4) - 1;
	return
end 
```

This takes a function whose domain is 3 and codomain is 1, divides the space between (-1.1, -1.1, -1.1, -1.1) and (1.1, 1.1, 1.1, 1.1) into five, in every dimension, then splits each subspace space into simplexes. It will then approximate where the `sphere4` function equals 0 and output it to the file `''sphere4.pol''`.


```
First      = [-1.1 -1.1 -1.1 -1.1];
Last       = [ 1.1  1.1  1.1  1.1];
Division   = [ 5    5    5    5  ]; 

FirstPoint = [ 0    0    0    1  ];

ContinuationSimplex(4, 1, First, Last, Division, FirstPoint, @sphere4, 'sphere4_cont.pol');

function [f] = sphere5(n,v) 
	f(1) = v(1)*v(1) + v(2)*v(2) + v(3)*v(3) + v(4)*v(4) - 1;
	return
end 
```

Here we do the same as above, but with the **ContinuationSimplex** function. It needs a point where `sphere3` equals 0 to start, so we supply it (0 0 1).

## Output

Both methods generate output files in the same format. To explain them, we will use the file generated by the first example given above, `sphere4.pol`.

```
  4   1
```
The first line contains two numbers, the `n` (domain) and `k` (codomain) of the function approximated.

```
  5   5   5   5 
```
The following line line contains `n` number, with how many times each dimension of the space was divided (the `Division` array).

Then we skip a line and in the following lines we have the same pattern, which will repeat until the end of the file.

```
  6   1   1   0   0 
```
The first number is a unique number for each subsection of the space. Then, follows `n` numbers, which identify said subsection.

```
  1
```
Then comes the number of connected components of this graph, the number of polytopes approximated in that region.

For each connected component, the folloing pattern repeats:

```
  4 
```
The number of vertices of said component.

```
  0  15     -0.22606040     -0.22606261     -0.66606062     -0.66606028 
  8  15     -0.22909058     -0.22909277     -0.66909080     -0.65999990 
 12  15     -0.23818117     -0.23818339     -0.66000020     -0.65999988 
 14  15     -0.25636240     -0.22000207     -0.66000012     -0.65999995 
```
For each vertex, the `k` + 1 numbers identifying the simplex that simplexes used to form the vertex, followed by `n` numbers, which are their location.

After the vertexes, follows `n` - `k` groupings of data. Each group represents polytopes in each dimension, so the first one represents edges, the second represents faces, the third spaces and so on, each referencing the previous list. 

Each one of them follows the same pattern, by first having the number of polytopes, then on the folloing lines lists describing said polytopes. So first we have the edges:

```
  6
  1   2 
  1   3 
  2   3 
  1   4 
  2   4 
  3   4 
```
Edge 1 is formed by vertices 1 and 2, Edge 2 is formed by vertices 1 and 3, and so on.

Now we have the Faces:
```
  4
  1   2   3 
  1   4   5 
  2   4   6 
  3   5   6 
```
There are four Faces. The first Face is formed by the Edges 1, 2 and 3, the second Face is formed by Edge 1, 4 and 5 and so on.

Now the Spaces:
```
  1
  1   2   3   4 
```
There is a single Space, defined by the the Faces 1, 2, 3 and 4. 

Therefore this section defines six vertexes, which in groups of 2 form 6 edges. These edges, in groups of 3, form 4 faces. The faces, in turn, all together form a single shape, a 3D pyramid of triangular base.

This pattern is repeated all the way to the end of the file, which will be signalled by
```
-1
```